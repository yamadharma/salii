################################################################################
#
#  logmsg
#
# Usage: log a message, redirects to console / syslog depending on usage
logmsg() {
	p_comment 10 "$@"
}

#
################################################################################
#
#  get_arch
#
# Usage: get_arch; echo $ARCH
get_arch() {
	ARCH=`uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/`

	if [ "ppc64" = "$ARCH" ]
	then
		# This takes a little bit of futzing with due to all the PPC platforms that exist.
		if [ -d /proc/iSeries ] ; then
			ARCH=ppc64-iSeries
		fi
		if grep -qs PS3 /proc/cpuinfo; then
			ARCH=ppc64-ps3
		fi
	fi
}

## adjust_arch
adjust_arch() {
	# Just to be compatible
	touch /tmp/adjust_arch
}

#
################################################################################
#
#  write_variables
#
# Usage: write_variables
write_variables() {

        cat /dev/null > /tmp/variables.txt

        echo "HOSTNAME=$HOSTNAME"                       >> /tmp/variables.txt
        echo "DOMAINNAME=$DOMAINNAME"                   >> /tmp/variables.txt
        echo "DEVICE=$DEVICE"                           >> /tmp/variables.txt
        echo "IPADDR=$IPADDR"                           >> /tmp/variables.txt
        echo "NETMASK=$NETMASK"                         >> /tmp/variables.txt
        echo "GATEWAY=$GATEWAY"                         >> /tmp/variables.txt
        echo "GATEWAYDEV=$GATEWAYDEV"                   >> /tmp/variables.txt
        echo "IMAGESERVER=$IMAGESERVER"                 >> /tmp/variables.txt
        echo "IMAGENAME=$IMAGENAME"                     >> /tmp/variables.txt

        echo "LOG_SERVER=$LOG_SERVER"                   >> /tmp/variables.txt
        echo "LOG_SERVER_PORT=$LOG_SERVER_PORT"         >> /tmp/variables.txt
        echo "USELOGGER=$USELOGGER"                     >> /tmp/variables.txt

        echo "SSH=$SSH"                                 >> /tmp/variables.txt
        echo "SSHD=$SSHD"                               >> /tmp/variables.txt
        echo "SSH_USER=$SSH_USER"                       >> /tmp/variables.txt
        echo "SSH_DOWNLOAD_URL=$SSH_DOWNLOAD_URL"       >> /tmp/variables.txt

        echo "MONITOR_SERVER=$MONITOR_SERVER"           >> /tmp/variables.txt
        echo "MONITOR_PORT=$MONITOR_PORT"               >> /tmp/variables.txt
        echo "MONITOR_CONSOLE=$MONITOR_CONSOLE"         >> /tmp/variables.txt 

        echo "PROTOCOL=$PROTOCOL"                       >> /tmp/variables.txt
        echo "STAGING=$STAGING"                         >> /tmp/variables.txt 

        echo "SALI_VERSION=`cat /etc/sali_version`"     >> /tmp/variables.txt
        
        ## Keep these two variables for compatibility
        # they are replaced by: PROTOCOL and STAGING
        #
        echo "BITTORRENT=$BITTORRENT"                   >> /tmp/variables.txt
        echo "BITTORRENT_STAGING=$BITTORRENT_STAGING"   >> /tmp/variables.txt

        echo "GROUPNAMES=\"$GROUPNAMES\""               >> /tmp/variables.txt
        echo "GROUP_OVERRIDES=\"$GROUP_OVERRIDES\""     >> /tmp/variables.txt 
        
        echo "VERBOSE_LEVEL=\"$VERBOSE_LEVEL\""           >> /tmp/variables.txt
        echo "ARCH=\"$ARCH\""                           >> /tmp/variables.txt

        echo "SCRUB=\"$SCRUB\""                         >> /tmp/variables.txt
        echo "SCRUB_DISKS=\"$SCRUB_DISKS\""             >> /tmp/variables.txt
        echo "SCRUB_REBOOT=\"$SCRUB_REBOOT\""           >> /tmp/variables.txt
        echo "SCRUB_HALT=\"$SCRUB_HALT\""               >> /tmp/variables.txt
        echo "SCRUB_OPTIONS=\"$SCRUB_OPTIONS\""         >> /tmp/variables.txt
}

################################################################################
#
#  Description: save_param is going to replace write_variables
#
# Usage: save_param KEY VALUE
#
# Example: save_param VERBOSE_LEVEL 2
save_param(){
    
    PARAM=$1
    VALUE=$2

    if [ ! -e "/tmp/variables.txt" ]
    then
        write_variables
    fi

    ##Which line must be removed!
    LINE=$(egrep -n "^$PARAM=" /tmp/variables.txt|awk -F : '{print $1}')

    if [ -n "${LINE}" ]
    then
        sed ''$LINE'd' /tmp/variables.txt > /tmp/variables.txt.new
        echo "$PARAM=\"$VALUE\"" >> /tmp/variables.txt.new

        mv /tmp/variables.txt.new /tmp/variables.txt
    else
        echo "$PARAM=\"$VALUE\"" >> /tmp/variables.txt
    fi

}

#
############################
#
# Description: source the variables
#
# Usage: load_variables
##
load_variables(){
    . /tmp/variables.txt
}

#
################################################################################
#
#   Description:
#   Exit with the message stored in /etc/si_error.
#
#   Usage: $COMMAND || shellout
#
shellout() {
	p_service "An error has occured, killing off running processes."

	killall -9 rsync  >/dev/null 2>/dev/null
	write_variables

	cat $ERROR_MSG_FILE

	if [ ! -z $MONITOR_SERVER ]; then
		p_comment 0 "installation failed!! stopping report task."
		stop_report_task -1
	fi

	exec cttyhack /bin/login -f root
}

#
################################################################################
#
#   Description:
#   Count the specified number, printing each number, and exit only the count
#   loop when <ctrl>+<c> is hit (SIGINT, or Signal 2).  Thanks to
#   CCB <ccb@acm.org> for this chunk of code.  -BEF-
#
#   Usage:
#   count_loop 35
#   count_loop $ETHER_SLEEP
#
count_loop() {

  COUNT=$1

  trap 'echo ; echo "Skipping ETHER_SLEEP -> Caught <ctrl>+<c>" ; I=$COUNT' INT

  I=0
  while [ $I -lt $COUNT ]; do
    I=$(( $I + 1 ))
    logmsg -n "$I "
    sleep 1
  done

  trap INT

  logmsg
}

#
################################################################################
#
# read in varibles obtained from kernel appends
#
read_kernel_append_parameters() {
    . /tmp/kernel_append_parameter_variables.txt
}
#
################################################################################
#
# Variable-ize /proc/cmdline arguments
#
variableize_kernel_append_parameters() {
    ## For compatability create the old parameters file
    cat /proc/cmdline | tr ' ' '\n' | grep '=' > /tmp/kernel_append_parameter_variables.txt

    ## Now save the rest to the variables.txt file
    for VAR in $(cat /proc/cmdline | sed 's/ /\n/g' | egrep "^[A-Z\_0-9]+=.+")
    do
        KEY=$(echo $VAR | awk -F"=" '{print $1}')
        VALUE=$(echo $VAR | awk -F"=" '{print $2}')
        save_param $KEY $VALUE
    done
}

#
################################################################################
#
# Look for local.cfg file
#   This code inspired by Ian McLeod <ian@valinux.com>
#
read_local_cfg() {
    logmsg
    logmsg read_local_cfg

    if [ "x$SKIP_LOCAL_CFG" = "xy" ]; then
        logmsg "skipping local.cfg: option SKIP_LOCAL_CFG=y has been specified"
        return
    fi

    # Try with local.cfg directly from initrd.
    if [ -f /local.cfg ]; then
        cp -f /local.cfg /tmp/local.cfg
    fi

    #
    # BEGIN try hard drive
    #
    if [ ! -z "$LAST_ROOT" ]; then

        logmsg
        logmsg "Checking for /local.cfg file on hard drive..."
        mkdir /last_root
        logmsg "Mounting hard drive..."
        mount $LAST_ROOT /last_root -o ro > /dev/null 2>&1
        if [ $? != 0 ]; then
            logmsg "FATAL: Couldn't mount hard drive!"
            logmsg "Your kernel must have all necessary block and filesystem drivers compiled in"
            logmsg "statically (not modules) in order to use a local.cfg on your hard drive.  The"
            logmsg "standard SystemImager kernel is modular, so you will need to compile your own"
            logmsg "kernel.  See the SystemImager documentation for details.  To proceed at this"
            logmsg "point, you will need to unset the LAST_ROOT append parameter by typing"
            logmsg ""systemimager LAST_ROOT=", or similar, at your boot prompt.  This will not use"
            logmsg "the local.cfg file on your hard drive, but will still use one on a floppy."
            shellout
        fi

        if [ -f /last_root/local.cfg ]; then
            logmsg "Found /local.cfg on hard drive."
            logmsg "Copying /local.cfg settings to /tmp/local.cfg."
            cat /last_root/local.cfg >> /tmp/local.cfg || shellout
        else
            logmsg "No /local.cfg on hard drive."
        fi
        logmsg "Unmounting hard drive..."
        umount /last_root || shellout
        logmsg
    fi
    # END try hard drive

    ### BEGIN try floppy ###
    logmsg "Checking for floppy diskette."
    logmsg 'YOU MAY SEE SOME "wrong magic" ERRORS HERE, AND THAT IS NORMAL.'
    mkdir -p /floppy
    mount /dev/fd0 /floppy -o ro > /dev/null 2>&1
    if [ $? = 0 ]; then
        logmsg "Found floppy diskette."
        if [ -f /floppy/local.cfg ]; then
            logmsg "Found /local.cfg on floppy."
            logmsg "Copying /local.cfg settings to /tmp/local.cfg."
            logmsg "NOTE: local.cfg settings from a floppy will override settings from"
            logmsg "      a local.cfg file on your hard drive and DHCP."
            # We use cat instead of copy, so that floppy settings can
            # override hard disk settings. -BEF-
            cat /floppy/local.cfg >> /tmp/local.cfg || shellout
        else
            logmsg "No /local.cfg on floppy diskette."
        fi
    else
        logmsg "No floppy diskette in drive."
    fi
    ### END try floppy ###

    # /tmp/local.cfg may be created from a local.cfg file on the hard drive, or a
    # floppy.  If both are used, settings on the floppy take precedence. -BEF-
    if [ -f /tmp/local.cfg ]; then
        logmsg "Reading configuration from /tmp/local.cfg"
        . /tmp/local.cfg || shellout
    fi
}
