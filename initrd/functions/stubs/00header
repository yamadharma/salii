#!/bin/sh
#
# "SystemImager" 
#
#  Copyright (C) 1999-2005 Brian Elliott Finley
#
#  $Id: functions 4468 2009-04-10 00:40:13Z bli $
#  vi: set filetype=sh et ts=4:
#
#  Others who have contributed to this code:
#   Charles C. Bennett, Jr. <ccb@acm.org>
#   Sean Dague <japh@us.ibm.com>
#   Dann Frazier <dannf@dannf.org>
#   Curtis Zinzilieta <czinzilieta@valinux.com>
#


################################################################################
#
#   Variables
#
PATH=/sbin:/bin:/usr/bin:/usr/sbin:/tmp
LD_LIBRARY_PATH=/lib
SCRIPTS=scripts
SCRIPTS_DIR=/scripts
TORRENTS=torrents
TORRENTS_DIR=/torrents
VERSION="SYSTEMIMAGER_VERSION_STRING"
FLAVOR="SYSTEMIMAGER_FLAVOR_STRING"
#
################################################################################


################################################################################
#
#   Subroutines
#
################################################################################
#
#  fs_on_tmpfs
#
# Usage: 
#   if fs_on_tmpfs /my_filesystem ; then
fs_on_tmpfs() {
    #XXX does this still work now with udev? -BEF-
    df 2>/dev/null | egrep 'tmpfs ' | egrep -q " $1\$" 
}

mknod_on_dev(){
        mknod -m 660 /dev/tty1 c 4 1
        mknod -m 660 /dev/tty2 c 4 2
        mknod -m 660 /dev/tty3 c 4 3
        mknod -m 660 /dev/tty4 c 4 4
        mknod -m 660 /dev/tty5 c 4 5
        mknod -m 660 /dev/tty6 c 4 6
        mknod -m 600 /dev/console c 5 1
        mknod -m 660 /dev/null c 1 3
        mknod -m 660 /dev/zero c 1 5
}

################################################################################
#
#  logmsg
#
# Usage: log a message, redirects to console / syslog depending on usage
logmsg() {
    # log to console
    echo $@
    # log to temporary file (which will go away when we reboot)
    # this is good for envs that have bad consoles
    local FILE=/tmp/si.log
    if fs_on_tmpfs / ; then
        echo $@ >> $FILE || shellout
    fi
    
    # if syslog is running, log to it.  In order to avoid hangs we have to 
    # add the "logger: " part in case $@ is ""
    if [ ! -z $USELOGGER ] ;
        then logger "logger: $@"
    fi
}


################################################################################
#
#  check_version
#
# Usage: check_version
check_version() {
    logmsg
    logmsg check_version
    INITRD_VERSION=$VERSION
    KERNEL_VERSION=`uname -r | sed -e s/.*boel_v//`
    if [ "$INITRD_VERSION" != "$KERNEL_VERSION" ] ; then
        logmsg "FATAL: Kernel version ($KERNEL_VERSION) doesn't match initrd version ($INITRD_VERSION)!"
        shellout
    fi
}
#
################################################################################
#
#  get_arch
#
# Usage: get_arch; echo $ARCH
get_arch() {
    logmsg
    logmsg get_arch
    ARCH=`uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ -e s/arm.*/arm/ -e s/sa110/arm/`
}
#
################################################################################
#
#  adjust_arch
#
#  based on info in /proc adjust the ARCH variable.  This needs to run
#  after proc is mounted.
#
adjust_arch() {
    logmsg
    logmsg adjust_arch
    if [ "ppc64" = "$ARCH" ] ; then
        # This takes a little bit of futzing with due to all the PPC platforms that exist.
        if [ -d /proc/iSeries ] ; then
            ARCH=ppc64-iSeries
            logmsg "Detected ppc64 is really an iSeries partition..."
        fi
        if grep -qs PS3 /proc/cpuinfo; then
            ARCH=ppc64-ps3
        fi
    fi
}
#
################################################################################
#
#  write_variables
#
# Usage: write_variables
write_variables() {

    logmsg
    logmsg write_variables

    if fs_on_tmpfs / ; then
        # pass all variables set here on to the hostname.sh script
        rm -f /tmp/variables.txt
        
        echo "HOSTNAME=$HOSTNAME"                   >> /tmp/variables.txt || shellout
        echo "DOMAINNAME=$DOMAINNAME"               >> /tmp/variables.txt
        
        echo "DEVICE=$DEVICE"                       >> /tmp/variables.txt
        echo "IPADDR=$IPADDR"                       >> /tmp/variables.txt
        echo "NETMASK=$NETMASK"                     >> /tmp/variables.txt
        echo "NETWORK=$NETWORK"                     >> /tmp/variables.txt
        echo "BROADCAST=$BROADCAST"                 >> /tmp/variables.txt
        
        echo "GATEWAY=$GATEWAY"                     >> /tmp/variables.txt
        echo "GATEWAYDEV=$GATEWAYDEV"               >> /tmp/variables.txt
        
        echo "IMAGESERVER=$IMAGESERVER"             >> /tmp/variables.txt
        echo "IMAGENAME=$IMAGENAME"                 >> /tmp/variables.txt
        
        echo "LOG_SERVER=$LOG_SERVER"               >> /tmp/variables.txt
        echo "LOG_SERVER_PORT=$LOG_SERVER_PORT" 	>> /tmp/variables.txt
        echo "USELOGGER=$USELOGGER"                 >> /tmp/variables.txt
        
        echo "TMPFS_STAGING=$TMPFS_STAGING"         >> /tmp/variables.txt
        
        echo "SSH=$SSH"	           	 		>> /tmp/variables.txt
        echo "SSHD=$SSHD"	            		>> /tmp/variables.txt
        echo "SSH_USER=$SSH_USER"	            	>> /tmp/variables.txt
        echo "SSH_DOWNLOAD_URL=$SSH_DOWNLOAD_URL"	>> /tmp/variables.txt
        
        echo "FLAMETHROWER_DIRECTORY_PORTBASE=$FLAMETHROWER_DIRECTORY_PORTBASE"	>> /tmp/variables.txt
        
        echo "MONITOR_SERVER=$MONITOR_SERVER"           >> /tmp/variables.txt
        echo "MONITOR_PORT=$MONITOR_PORT"               >> /tmp/variables.txt
        echo "MONITOR_CONSOLE=$MONITOR_CONSOLE"         >> /tmp/variables.txt

        echo "BITTORRENT=$BITTORRENT"                   >> /tmp/variables.txt
        echo "BITTORRENT_STAGING=$BITTORRENT_STAGING"   >> /tmp/variables.txt
        echo "BITTORRENT_POLLING_TIME=$BITTORRENT_POLLING_TIME" >> /tmp/variables.txt
        echo "BITTORRENT_SEED_WAIT=$BITTORRENT_SEED_WAIT"       >> /tmp/variables.txt
        echo "BITTORRENT_UPLOAD_MIN=$BITTORRENT_UPLOAD_MIN"     >> /tmp/variables.txt

        echo "GROUPNAMES=\"$GROUPNAMES\""     >> /tmp/variables.txt
        echo "GROUP_OVERRIDES=\"$GROUP_OVERRIDES\""     >> /tmp/variables.txt
    fi
}
#
################################################################################
#
#   Description:
#   watches the tmpfs filesystem (/) and gives warnings and/or does a shellout
#
#   Usage: tmpfs_watcher
#
tmpfs_watcher() {

    logmsg
    logmsg tmpfs_watcher

    # Note: Transfer to staging area can fail if tmpfs runs out of inodes.
    {
        while :; do
            DF=`df -k / | egrep ' /$' | sed -e 's/  */ /g' -e 's/.*[0-9] //' -e 's/%.*//'`
            [ $DF -ge 95 ] && logmsg "WARNING: Your tmpfs filesystem is ${DF}% full!"
            [ $DF -ge 99 ] && logmsg "         Search the FAQ for tmpfs to learn about sizing options."
            [ $DF -ge 99 ] && shellout
            sleep 1
        done
        unset DF
    }&
    TMPFS_WATCHER_PID=$!
}
#
################################################################################
#
#   Description:
#   Exit with the message stored in /etc/issue.
#
#   Usage: $COMMAND || shellout
#
shellout() {
    COUNT="$RETRY"
    logmsg "Killing off running processes."
    kill -9 $TMPFS_WATCHER_PID  >/dev/null 2>/dev/null
    killall -9 udp-receiver rsync  >/dev/null 2>/dev/null
    write_variables
    cat /etc/issue
    if [ ! -z $USELOGGER ] ;
        then cat /etc/issue | logger
    fi
    if [ ! -z $MONITOR_SERVER ]; then
    	logmsg "Installation failed!! Stopping report task."
        stop_report_task -1
    fi
    exec sh > /dev/console 2>&1
}

##
# This function has been added to open a console without any errors
shellopen() {
	logmsg
	logmsg "Starting console..."

	if [ ! -z $MONITOR_SERVER ]; then
		logmsg "Strating console, stopping monitoring"
		stop_report_task -1
	fi

	exec sh > /dev/console 2>&1
}
#
################################################################################
#
#   Description:  
#   Count the specified number, printing each number, and exit only the count
#   loop when <ctrl>+<c> is hit (SIGINT, or Signal 2).  Thanks to 
#   CCB <ccb@acm.org> for this chunk of code.  -BEF-
#
#   Usage: 
#   count_loop 35
#   count_loop $ETHER_SLEEP
#
count_loop() {

  COUNT=$1

  trap 'echo ; echo "Skipping ETHER_SLEEP -> Caught <ctrl>+<c>" ; I=$COUNT' INT

  I=0
  while [ $I -lt $COUNT ]; do
    I=$(( $I + 1 ))
    logmsg -n "$I "
    sleep 1
  done

  trap INT

  logmsg
}
#
################################################################################
#
# Usage: get_torrents_directory
#
get_torrents_directory() {

    if [ ! "x$BITTORRENT" = "xy" ]; then
        return
    fi

    logmsg
    logmsg get_torrents_directory

    mkdir -p ${TORRENTS_DIR}
    CMD="rsync -a ${IMAGESERVER}::${TORRENTS}/ ${TORRENTS_DIR}/"
    logmsg "$CMD"
    $CMD
}
#
################################################################################
#
# Usage: get_scripts_directory
#
get_scripts_directory() {
    logmsg
    logmsg get_scripts_directory

    mkdir -p ${SCRIPTS_DIR}
    CMD="rsync -a ${IMAGESERVER}::${SCRIPTS}/ ${SCRIPTS_DIR}/"
    logmsg "$CMD"
    $CMD
}

#
################################################################################
#
#   Autodetect a staging directory for the bittorrent tarball
#
#   Usage: bittorrent_autodetect_staging_dir torrent
#
## SALI Replaced Bittorrent with Aria2
bittorrent_autodetect_staging_dir() {
    torrent_file=$1
    if [ ! -f $torrent_file ]; then
        logmsg "warning: torrent file $torrent_file does not exist!"
        return
    fi

    # List of preferred staging directory (/tmp = ramdisk staging)
    logmsg "Getting disks for storing"
    preferred_dirs="/tmp /a/tmp `df 2>/dev/null | sed '1d' | sed 's/[[:space:]]\+/ /g' | cut -d' ' -f6`"
    logmsg "Disks: $preferred_dirs"

    # Use a breathing room of 100MB (this should be enough for a lot of cases)
    breathing_room=102400

    # Evaluate torrent size
    logmsg "Getting torrent size"
    torrent_size=$(( $( (aria2c -S $torrent_file | awk '/Total Length:/ { print $4}' | sed 's/[(),]*//g' ) ) / 1024 + $breathing_room ))
    logmsg "Torrent size: $torrent_size"

    # Find a directory to host the image tarball
    for dir in $preferred_dirs; do
        [ ! -d $dir ] && continue;
        dir_space=`df $dir 2>/dev/null | sed '1d' | sed 's/[[:space:]]\+/ /g' | cut -d' ' -f4 | sed -ne '$p'`
        [ -z $dir_space ] && continue
        [ $torrent_size -lt $dir_space ] && echo $dir && return
    done
}
#
################################################################################
#
#   Check the output of aria2.
#
#   Usage: bittorrent_check_log pattern logfile
#
## SALI This function has been added to monitor the log of Aria2
bittorrent_check_log(){
	PATTERN=$1
	FILE=$2

	CURRENTLINE=$(tail -n 1 $FILE)
	RSLT=$(echo $CURRENTLINE | egrep $PATTERN | cut -d " " -f 2)

	if [ $RSLT ]; then
		echo "$RSLT"
	fi
}

#
################################################################################
#
#   Download a file using bittorrent.
#
#   Usage: bittorrent_get_file torrent destination
#
## SALI Replaced Bittorrent with Aria2, removed check when transfer drops
## below a specified speed. Aria2c stops automaticly when the share ration is 1.0
bittorrent_get_file() {
        torrent=$1
        destination=$2

        # Bittorrent log file
        bittorrent_log=/tmp/bittorrent.log

	##Starting aria2c and sending the stdout to a file
	logmsg "/usr/bin/aria2c --human-readable=false --dir $destination $torrent_file > $bittorrent_log &"
	/usr/bin/aria2c --human-readable=false --dir $destination $torrent_file > $bittorrent_log &
	
	pid=$!
	if [ ! -d /proc/$pid ]; then
		logmsg "Bittorrent client not running"
		shellout
	fi

	echo $pid > /var/run/aria2c.pid

	downloadpattern="(SIZE:[0-9]+B/[0-9]+B\([0-9]{1,2}1{0,1}\%\))"
	donepattern="(SEEDING\(ratio:[0-9.]+\))"


	cntr=0
	while : ; do
		if [ -e $bittorrent_log ]; then
			break
		else
			cntr=$(($cntr+1))
			sleep 5
		fi

		if [ cntr -gt 5 ]; then
			logmsg "Torrent client not running"
			shellout
		fi
	done

	while : ; do
		SEED=$(bittorrent_check_log $donepattern $bittorrent_log)
		DOWNLOAD=$(bittorrent_check_log $downloadpattern $bittorrent_log)

		if [ $SEED ]; then
			echo "Download complete"
			break
		elif [ $DOWNLOAD ]; then
			echo "Downloading: $DOWNLOAD"
			sleep 2
		fi
	done
}
#
################################################################################
#
#   Stop bittorrent client.
#
#   Usage: bittorrent_stop
#
## SALI This function is decapricated
bittorrent_stop() {
	logmsg
	logmsg "This function is decapricated, the bittorrent client keeps running until a reboot!"
}
#
################################################################################
#
# Parse tmpfs options from /proc/cpuinfo
# 
parse_tmpfs_opts() {
    logmsg
    logmsg parse_tmpfs_opts
    mount_proc
    tmpfs_size=$(tr ' ' '\n' < /proc/cmdline | grep tmpfs_size\= | sed 's/.*=//')
    tmpfs_nr_blocks=$(tr ' ' '\n' < /proc/cmdline | grep tmpfs_nr_blocks\= | sed 's/.*=//')
    tmpfs_nr_inodes=$(tr ' ' '\n' < /proc/cmdline | grep tmpfs_nr_inodes\= | sed 's/.*=//')
    tmpfs_mode=$(tr ' ' '\n' < /proc/cmdline | grep tmpfs_mode\= | sed 's/.*=//')
    umount /proc

    if [ "$tmpfs_size" != "" ]; then
        tmpfs_opts="size=$tmpfs_size"
    fi

    if [ "$tmpfs_nr_blocks" != "" ]; then
        if [ "$tmpfs_opts" != "" ]; then
            tmpfs_opts="${tmpfs_opts},nr_blocks=$tmpfs_nr_blocks"
        else
            tmpfs_opts="nr_blocks=$tmpfs_nr_blocks"
        fi
    fi

    if [ "$tmpfs_nr_inodes" != "" ]; then
        if [ "$tmpfs_opts" != "" ]; then
            tmpfs_opts="${tmpfs_opts},nr_inodes=$tmpfs_nr_inodes"
        else
            tmpfs_opts="nr_inodes=$tmpfs_nr_inodes"
            fi
    fi

    if [ "$tmpfs_mode" != "" ]; then
        if [ "$tmpfs_opts" != "" ]; then
            tmpfs_opts="${tmpfs_opts},mode=$tmpfs_mode"
        else
            tmpfs_opts="mode=$tmpfs_mode"
        fi
    fi

    if [ "$tmpfs_opts" != "" ]; then
        tmpfs_opts="-o $tmpfs_opts"
    fi

    unset tmpfs_size
    unset tmpfs_nr_blocks
    unset tmpfs_nr_inodes
    unset tmpfs_mode
}
#
################################################################################
#
#   Switch root to tmpfs
#
switch_root_to_tmpfs() {
    local MODULE=tmpfs
    logmsg
    logmsg switch_root_to_tmpfs
    logmsg
    logmsg "Loading $MODULE... "
    modprobe $MODULE 2>/dev/null && logmsg "done!" || logmsg "Didn't load -- assuming it's built into the kernel."
    parse_tmpfs_opts

    # Switch root over to tmpfs so we don't have to worry about the size of
    # the tarball and binaries that users may decide to copy over. -BEF-
    if [ -d /old_root ]; then
        logmsg
        logmsg "already switched to tmpfs..."
    else
        logmsg
        logmsg "switching root to tmpfs..."

        mkdir -p /new_root || shellout
        mount tmpfs /new_root -t tmpfs $tmpfs_opts || shellout
        cd / || shellout
        cp -a `/bin/ls | grep -v new_root` /new_root/ || shellout
        cd /new_root || shellout
        mkdir -p old_root || shellout
        pivot_root . old_root || switch_root
    fi

    unset tmpfs_opts
}
#
################################################################################
#
# Now mount proc. -BEF-
mount_proc() {
    logmsg
    logmsg mount_proc
    mkdir -p /proc || shellout
    mount proc /proc -t proc || shellout
}
#
################################################################################
#
mount_sys() {
    logmsg
    logmsg mount_sys
    mkdir -p /sys || shellout
    if grep -q '[[:space:]]\+sysfs$' /proc/filesystems 2>/dev/null; then
        mount sysfs /sys -t sysfs || shellout
    else
        logmsg "sysfs is not supported by the kernel: `uname -r`"
    fi
}
#
################################################################################
#
mount_pts() {
    logmsg
    logmsg mount_pts
    mkdir -p /dev/pts || shellout
    mount devpts /dev/pts -t devpts || shellout
}
#
################################################################################
#
monitor_save_dmesg() {
    if [ -z $MONITOR_SERVER ]; then
        return
    fi
    logmsg
    logmsg monitor_save_dmesg
    dmesg -s 16392 > /tmp/si_monitor.log
}
#
################################################################################
#
## SALI Just start udev, don't use the static dev.tar.gz
start_udevd() {
    #
    # Start udevd first, then hotplug

    logmsg
    logmsg start_udevd
    /etc/init.d/udev start

}
#
################################################################################
#
# Configure loopback interface (may as well)
ifconfig_loopback() {
    logmsg
    logmsg ifconfig_loopback
    ifconfig lo 127.0.0.1
}

#
################################################################################
#
# read in varibles obtained from kernel appends
#
read_kernel_append_parameters() {
    logmsg
    logmsg read_kernel_append_parameters

    . /tmp/kernel_append_parameter_variables.txt
}
#
################################################################################
#
# Variable-ize /proc/cmdline arguments
#
variableize_kernel_append_parameters() {
    logmsg
    logmsg variableize_kernel_append_parameters
    cat /proc/cmdline | tr ' ' '\n' | grep '=' > /tmp/kernel_append_parameter_variables.txt
}
#
################################################################################
#
# Look for local.cfg file
#   This code inspired by Ian McLeod <ian@valinux.com>
#
read_local_cfg() {
    logmsg
    logmsg read_local_cfg

    if [ "x$SKIP_LOCAL_CFG" = "xy" ]; then
        logmsg "skipping local.cfg: option SKIP_LOCAL_CFG=y has been specified"
        return
    fi

    # Try with local.cfg directly from initrd.
    if [ -f /local.cfg ]; then
        cp -f /local.cfg /tmp/local.cfg
    fi

    #
    # BEGIN try hard drive
    #
    if [ ! -z "$LAST_ROOT" ]; then

        logmsg
        logmsg "Checking for /local.cfg file on hard drive..."
        mkdir /last_root
        logmsg "Mounting hard drive..."
        mount $LAST_ROOT /last_root -o ro > /dev/null 2>&1
        if [ $? != 0 ]; then
            logmsg "FATAL: Couldn't mount hard drive!"
            logmsg "Your kernel must have all necessary block and filesystem drivers compiled in"
            logmsg "statically (not modules) in order to use a local.cfg on your hard drive.  The"
            logmsg "standard SystemImager kernel is modular, so you will need to compile your own"
            logmsg "kernel.  See the SystemImager documentation for details.  To proceed at this"
            logmsg "point, you will need to unset the LAST_ROOT append parameter by typing"
            logmsg ""systemimager LAST_ROOT=", or similar, at your boot prompt.  This will not use"
            logmsg "the local.cfg file on your hard drive, but will still use one on a floppy."
            shellout
        fi

        if [ -f /last_root/local.cfg ]; then
            logmsg "Found /local.cfg on hard drive."
            logmsg "Copying /local.cfg settings to /tmp/local.cfg."
            cat /last_root/local.cfg >> /tmp/local.cfg || shellout
        else
            logmsg "No /local.cfg on hard drive."
        fi
        logmsg "Unmounting hard drive..."
        umount /last_root || shellout
        logmsg
    fi
    # END try hard drive

    ### BEGIN try floppy ###
    logmsg "Checking for floppy diskette."
    logmsg 'YOU MAY SEE SOME "wrong magic" ERRORS HERE, AND THAT IS NORMAL.'
    mkdir -p /floppy
    mount /dev/fd0 /floppy -o ro > /dev/null 2>&1
    if [ $? = 0 ]; then
        logmsg "Found floppy diskette."
        if [ -f /floppy/local.cfg ]; then
            logmsg "Found /local.cfg on floppy."
            logmsg "Copying /local.cfg settings to /tmp/local.cfg."
            logmsg "NOTE: local.cfg settings from a floppy will override settings from"
            logmsg "      a local.cfg file on your hard drive and DHCP."
            # We use cat instead of copy, so that floppy settings can
            # override hard disk settings. -BEF-
            cat /floppy/local.cfg >> /tmp/local.cfg || shellout
        else
            logmsg "No /local.cfg on floppy diskette."
        fi
    else
        logmsg "No floppy diskette in drive."
    fi
    ### END try floppy ###

    # /tmp/local.cfg may be created from a local.cfg file on the hard drive, or a
    # floppy.  If both are used, settings on the floppy take precedence. -BEF-
    if [ -f /tmp/local.cfg ]; then
        logmsg "Reading configuration from /tmp/local.cfg"
        . /tmp/local.cfg || shellout
    fi
}

#
################################################################################
#
start_syslogd() {
    logmsg
    logmsg start_syslogd
    if [ ! -z $LOG_SERVER ]; then
        logmsg "Starting syslogd..."
        [ -z $LOG_SERVER_PORT ] && LOG_SERVER_PORT="514"
        syslogd -R ${LOG_SERVER}:${LOG_SERVER_PORT}
        # as long as we are starting syslogd, start klogd as well, in case
        # there is a kernel issue that happens
        klogd
        # set USELOGGER=1 so logmsg knows to do the right thing
        USELOGGER=1
        logmsg "Successfully started syslogd!"
    fi
}

#
################################################################################
#
choose_autoinstall_script() {

    logmsg
    logmsg choose_autoinstall_script

    #
    # Get the base hostname for the last attempt at choosing an autoinstall
    # script.  For example, if the hostname is compute99, then try to get 
    # compute.master. -BEF-
    #
    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    # 
    # If SCRIPTNAME is specified as a kernel append, or via local.cfg, then use that script.
    #
    if [ ! -z $SCRIPTNAME ]; then
        #
        # SCRIPTNAME was specified, but let's be flexible.  Try explicit first, then .master, .sh. -BEF-
        #
        SCRIPTNAMES="${SCRIPTS_DIR}/${SCRIPTNAME} ${SCRIPTS_DIR}/${SCRIPTNAME}.sh ${SCRIPTS_DIR}/${SCRIPTNAME}.master"

    else
        # 
        # If SCRIPTNAME was not specified, choose one, in order of preference.  First hit wins.
        # Order of preference is:
        #   HOSTNAME                (i.e. node001.sh)
        #   GROUPNAMES              (i.e. Login.sh) - see /etc/systemimager/cluster.xml on the image server
        #   BASE_HOSTNAME           (i.e. node.sh)
        #   IMAGENAME               (i.e. ubuntu7_04.sh)
        #
        [ ! -z $HOSTNAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${HOSTNAME}.sh ${SCRIPTS_DIR}/${HOSTNAME}.master"
        for GROUPNAME in $GROUPNAMES; do
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${GROUPNAME}.sh ${SCRIPTS_DIR}/${GROUPNAME}.master"
        done
        unset GROUPNAME
        [ ! -z $BASE_HOSTNAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${BASE_HOSTNAME}.sh ${SCRIPTS_DIR}/${BASE_HOSTNAME}.master"
        [ ! -z $IMAGENAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${IMAGENAME}.sh ${SCRIPTS_DIR}/${IMAGENAME}.master"
    fi

    #
    # Choose a winner!
    #
    for SCRIPTNAME in $SCRIPTNAMES
    do
        [ -e $SCRIPTNAME ] && break
    done

    # Did we really find one, or just exit the loop without a 'break'
    if [ ! -e $SCRIPTNAME ]; then
        logmsg "FATAL: couldn't find any of the following autoinstall scripts!"
        logmsg "---"
        logmsg ${SCRIPTNAMES}
        logmsg "---"
	logmsg "Be sure that at least one of the scripts above exists in"
        logmsg "the autoinstall scripts directory on your image server."
        logmsg
        logmsg "See also: si_mkautoinstallscript(8)."
        shellout
    fi
    logmsg "Using autoinstall script: ${SCRIPTNAME}"
}
#
################################################################################
#
run_autoinstall_script() {

    logmsg
    logmsg run_autoinstall_script

    # Run the autoinstall script.
    chmod 755 $SCRIPTNAME || shellout
    logmsg ">>> $SCRIPTNAME"
    $SCRIPTNAME || shellout
}
#
################################################################################
#
# Description: remove duplicated elements from a list, preserving the order.
#
unique() {
    ret=
    for i in $*; do
        flag=0
        for j in $ret; do
            [ "$i" = "$j" ] && flag=1 && break
        done
        [ $flag -eq 0 ] && ret="$ret $i"
    done
    echo $ret
    unset i j flag ret
}
#
################################################################################
#
# Description: reverse a list
#
reverse() {
    ret=
    for i in $*; do
        ret="$i $ret"
    done
    echo $ret
    unset i
}
#
################################################################################
#
run_pre_install_scripts() {

    logmsg
    logmsg run_pre_install_scripts

    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    if [ -e "${SCRIPTS_DIR}/pre-install/" ]; then

        cd ${SCRIPTS_DIR}/pre-install/

        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]all\..*"`"
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${IMAGENAME}\..*"`"
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${BASE_HOSTNAME}\..*"`"
        for GROUPNAME in ${GROUPNAMES}; do
            PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${GROUPNAME}\..*"`"
        done
        unset GROUPNAME
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${HOSTNAME}\..*"`"

        # Now, to get rid of those pesky newlines. -BEF-
        PRE_INSTALL_SCRIPTS=`echo $PRE_INSTALL_SCRIPTS | tr '\n' ' '`
        
        if [ ! -z "`echo ${PRE_INSTALL_SCRIPTS}|sed 's/ //'`" ]; then

            for PRE_INSTALL_SCRIPT in `unique $PRE_INSTALL_SCRIPTS`
            do
                logmsg ">>> $PRE_INSTALL_SCRIPT"
                chmod +x $PRE_INSTALL_SCRIPT || shellout
                ./$PRE_INSTALL_SCRIPT || shellout
            done
        else
            logmsg "No pre-install scripts found."
        fi

        if [ -e "/tmp/pre-install_variables.txt" ]; then
            . /tmp/pre-install_variables.txt
        fi

    fi
}
#
################################################################################
#
run_post_install_scripts() {

    logmsg
    logmsg run_post_install_scripts

    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    if [ -e "${SCRIPTS_DIR}/post-install/" ]; then

        # make a copy of variables.txt available to post-install scripts -BEF-
        cp -f /tmp/variables.txt ${SCRIPTS_DIR}/post-install/

        cd ${SCRIPTS_DIR}/post-install/

        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]all\..*"`"
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${IMAGENAME}\..*"`"
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${BASE_HOSTNAME}\..*"`"
        for GROUPNAME in ${GROUPNAMES}; do
            POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${GROUPNAME}\..*"`"
        done
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${HOSTNAME}\..*"`"

        # Now, to get rid of those pesky newlines. -BEF-
        POST_INSTALL_SCRIPTS=`echo $POST_INSTALL_SCRIPTS | tr '\n' ' '`
        
        if [ ! -z "`echo ${POST_INSTALL_SCRIPTS}|sed 's/ //'`" ]; then

            mkdir -p /a/tmp/post-install/ || shellout

            rsync -a ${SCRIPTS_DIR}/post-install/ /a/tmp/post-install/ || shellout

            for POST_INSTALL_SCRIPT in `unique $POST_INSTALL_SCRIPTS`
            do
                if [ -e "$POST_INSTALL_SCRIPT" ]; then
                    logmsg ">>> $POST_INSTALL_SCRIPT"
                    chmod +x /a/tmp/post-install/$POST_INSTALL_SCRIPT || shellout
                    chroot /a/ /tmp/post-install/$POST_INSTALL_SCRIPT || shellout
                fi
            done
        else
            logmsg "No post-install scripts found."
        fi

        # Clean up post-install script directory.
        rm -rf /a/tmp/post-install/ || shellout
    fi
}

#
################################################################################
#
#  send_monitor_msg
#
#   Description:
#   Redirect a message to the monitor server.
#
#   Usage: send_monitor_msg "var=$msg"
#

send_monitor_msg() {
    if [ -z $MONITOR_SERVER ]; then
        return
    fi
    if [ -z $MONITOR_PORT ]; then
        MONITOR_PORT=8181
    fi

    # Message to send.
    msg=`echo "$@"`

    # Get the client mac address.
    if [ -z "$mac" ]; then
        mac=`ifconfig $DEVICE 2>/dev/null | sed -ne "s/.*HWaddr //p" | sed "s/ //g" | sed s/:/./g`
    fi

    # Collect some special info only after proc file system is mounted.
    if [ `mount 2>/dev/null | grep proc > /dev/null; echo $?` -eq 0 ]; then
        # Collect the CPU info.
        if [ -z "$cpu" ]; then
            cpu=$(echo `cat /proc/cpuinfo | grep "cpu\|clock\|model name\|cpu MHz" | grep -v "cpu family" | sed -ne '1,2p' | sed "s/.*: //" | sed "s/^\([0-9\.]*\)MHz$/(\1 MHz)/" | sed "s/^\([0-9\.]*\)$/(\1 MHz)/"` | sed "s/\(MHz)\)/\1 |/g" | sed "s/ |$//")
        fi

        # Collect the number of CPUs.     
        if [ -z "$ncpus" ]; then
            ncpus=$((`cat /proc/cpuinfo | grep "^processor" | sed -n '$p' | sed "s/.*: \([0-9]\)*$/\1/"` + 1))
        fi

        # Collect the kernel information.
        if [ -z "$kernel_name" ]; then
            kernel_name=`uname -r`
        fi

        # Collect the amount of phyisical memory.
        if [ -z "$mem" ]; then
            mem=`cat /proc/meminfo | sed -ne "s/MemTotal: *//p" | sed "s/ kB//"`
        fi

        # Evaluate the amount of available RAM.
        tmpfs=`df | grep tmpfs | grep "/$" | sed "s/.* \([0-9]*%\) .*/\1/"`

        # Evaluate the uptime of the client.
        time=`cat /proc/uptime | sed "s/\..*//"`
    fi

    # Report the message to the monitor server.
    send_msg=`echo "mac=$mac:ip=$IPADDR:host=$HOSTNAME:cpu=$cpu:ncpus=$ncpus:kernel=$kernel_name:mem=$mem:os=$IMAGENAME:tmpfs=$tmpfs:time=$time:$msg"`

    # Send data to monitor server.
    echo "$send_msg" | nc $MONITOR_SERVER $MONITOR_PORT
}
#
################################################################################
#
#  send_monitor_stdout
#
#   Description:
#   Redirect a stdout of a command to the monitor console.
#
#   Usage: <cmd> | send_monitor_stdout
#

send_monitor_stdout() {
    while read l; do
        # echo to the console -AR-
        echo "$l"
        # Send the message to the monitor daemon.
        if [ "x$MONITOR_CONSOLE" = "xy" ]; then
            MONITOR_CONSOLE=yes
        fi
        if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
            # Log message into the global monitor log.
            if fs_on_tmpfs / ; then
                echo "$l" >> /tmp/si_monitor.log
            fi
        fi
    done
}
#
################################################################################
#
#   Initialize the monitor server
#

init_monitor_server() {
    # Send initialization status.
    send_monitor_msg "status=0:first_timestamp=on:speed=0"
    logmsg "Monitoring initialized."
    # Start client log gathering server: for each connection
    # to the local client on port 8181 the full log is sent
    # to the requestor. -AR-
    if [ "x$MONITOR_CONSOLE" = "xy" ]; then
        MONITOR_CONSOLE=yes
    fi
    if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
        while :; do nc -p 8181 -l < /tmp/si_monitor.log; done &
    fi
}
#
################################################################################
#
#   Report installation status to the monitor server
#

start_report_task() {
    # Reporting interval (in sec).
    REPORT_INTERVAL=10

    # Evaluate image size.
    logmsg "Evaluating image size..."
    if [ ! "x$BITTORRENT" = "xy" ]; then
        IMAGESIZE=`rsync -av --numeric-ids $IMAGESERVER::$IMAGENAME | grep "total size" | sed -e "s/total size is \([0-9]*\).*/\1/"`
    else
        if [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent" ]; then
            torrent_file="${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent"
        elif [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent" ]; then
            torrent_file="${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent"
        else
            logmsg "error: cannot find a valid torrent file for image ${IMAGENAME}"
            shellout
        fi
        IMAGESIZE=`aria2c -S $torrent_file | awk '/Total Length:/ { print $4}' | sed 's/[(),]*//g'`
    fi
    IMAGESIZE=`expr $IMAGESIZE / 1024`
    logmsg "  --> Image size = `expr $IMAGESIZE / 1024`MiB"

    # Evaluate disks size.
    LIST=`df 2>/dev/null | grep "/" | sed "s/  */ /g" | cut -d' ' -f3 | sed -ne 's/^\([0-9]*\)$/\1+/p'`0
    DISKSIZE=`echo $LIST | bc`

    # Spawn the report task -AR-
    {
    TOT=0; CURR_SIZE=0
    while :; do
        LIST=`df 2>/dev/null | grep "/" | sed "s/  */ /g" | cut -d' ' -f3 | sed -ne 's/^\([0-9]*\)$/\1+/p'`0
        TOT=`echo $LIST | bc`

        # Evaluate bandwidth.
        speed=`echo "scale=2; (($TOT - $DISKSIZE) - $CURR_SIZE) / $REPORT_INTERVAL" | bc`
        speed=`echo "scale=2; if ($speed >= 0) { print $speed; } else { print 0; }" | bc`

        # Evaluate status.
        CURR_SIZE=$(($TOT - $DISKSIZE))
        status=`echo "scale=2; $CURR_SIZE * 100 / $IMAGESIZE" | bc`
        if [ `echo "scale=2; $status <= 0" | bc` -eq 1 ]; then 
            status=1
        elif [ `echo "scale=2; $status >= 100" | bc` -eq 1 ]; then
            status=99
        fi

        # Send status and bandwidth to the monitor server.
        send_monitor_msg "status=$status:speed=$speed"
        
        # Wait $REPORT_INTERVAL sec between each report -AR-
        sleep $REPORT_INTERVAL
    done
    }&

    logmsg "Report task started."
    REPORT_PID=$!
}
#
################################################################################
#
#   Stop to report installation status to the monitor server
#

stop_report_task() {
    if [ ! -z $REPORT_PID ]; then
        kill -9 $REPORT_PID
        logmsg "Report task stopped."
    fi

    # Try to report the error to the monitor server.
    send_monitor_msg "status=$1:speed=0"
}
#
################################################################################
#
#   Beep incessantly
#
beep_incessantly() {
    local SECONDS=1
    local MINUTES
    local MINUTES_X_SIXTY
    { while :;
        do
            echo -n -e "\\a"
            if [ $SECONDS -lt 60 ]; then 
                logmsg "I have been done for $SECONDS seconds.  Reboot me already!"
            else
                MINUTES=`echo "$SECONDS / 60"|bc`
                MINUTES_X_SIXTY=`echo "$MINUTES * 60"|bc`
                if [ "$MINUTES_X_SIXTY" = "$SECONDS" ]; then 
                    logmsg "I have been done for $MINUTES minutes now.  Reboot me already!"
                fi  
            fi
            sleep 1
            SECONDS=`echo "$SECONDS + 1"|bc`
        done
    }
}
#
################################################################################
#
#   Beep incessantly
#
# Usage: beep [$COUNT [$INTERVAL]]
# Usage: beep
beep() {
    local COUNT=$1
    local INTERVAL=$2

    [ -z $COUNT ] && COUNT=1
    [ -z $INTERVAL ] && INTERVAL=1

    local COUNTED=0
    until [ "$COUNTED" = "$COUNT" ]
    do
        echo -n -e "\\a"
        sleep $INTERVAL
        COUNTED=$(( $COUNTED + 1 ))
    done
}
#
################################################################################
#
#   Print out dots while sleeping
#
# Usage: sleep_loop [[$COUNT [$INTERVAL]] $CHARACTER]
# Usage: sleep_loop
sleep_loop() {
    local COUNT=$1
    local INTERVAL=$2
    local CHARACTER=$3
    local COUNTED

    [ -z $COUNT ] && COUNT=1
    [ -z $INTERVAL ] && INTERVAL=1
    [ -z $CHARACTER ] && CHARACTER=.

    COUNTED=0
    until [ "$COUNTED" = "$COUNT" ]
    do
        echo -n "$CHARACTER"
        sleep $INTERVAL
        COUNTED=$(( $COUNTED + 1 ))
    done
}
#
################################################################################
