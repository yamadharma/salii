#!/bin/sh
#
# "SystemImager" 
#
#  Copyright (C) 1999-2005 Brian Elliott Finley
#
#  $Id: functions 4468 2009-04-10 00:40:13Z bli $
#  vi: set filetype=sh et ts=4:
#
#  Others who have contributed to this code:
#   Charles C. Bennett, Jr. <ccb@acm.org>
#   Sean Dague <japh@us.ibm.com>
#   Dann Frazier <dannf@dannf.org>
#   Curtis Zinzilieta <czinzilieta@valinux.com>
#


################################################################################
#
#   Variables
#
PATH=/sbin:/bin:/usr/bin:/usr/sbin:/tmp
LD_LIBRARY_PATH=/lib
SCRIPTS=scripts
SCRIPTS_DIR=/scripts
TORRENTS=torrents
TORRENTS_DIR=/torrents
VERSION="SYSTEMIMAGER_VERSION_STRING"
FLAVOR="SYSTEMIMAGER_FLAVOR_STRING"
#
################################################################################

#
################################################################################
#
#   Switch root to tmpfs
#
switch_root_to_tmpfs() {
    local MODULE=tmpfs
    logmsg
    logmsg switch_root_to_tmpfs
    logmsg
    logmsg "Loading $MODULE... "
    modprobe $MODULE 2>/dev/null && logmsg "done!" || logmsg "Didn't load -- assuming it's built into the kernel."
    parse_tmpfs_opts

    # Switch root over to tmpfs so we don't have to worry about the size of
    # the tarball and binaries that users may decide to copy over. -BEF-
    if [ -d /old_root ]; then
        logmsg
        logmsg "already switched to tmpfs..."
    else
        logmsg
        logmsg "switching root to tmpfs..."

        mkdir -p /new_root || shellout
        mount tmpfs /new_root -t tmpfs $tmpfs_opts || shellout
        cd / || shellout
        cp -a `/bin/ls | grep -v new_root` /new_root/ || shellout
        cd /new_root || shellout
        mkdir -p old_root || shellout
        pivot_root . old_root || switch_root
    fi

    unset tmpfs_opts
}
#
################################################################################
#
monitor_save_dmesg() {
    if [ -z $MONITOR_SERVER ]; then
        return
    fi
    logmsg
    logmsg monitor_save_dmesg
    dmesg -s 16392 > /tmp/si_monitor.log
}
#
################################################################################
#
## SALI Just start udev, don't use the static dev.tar.gz
start_udevd() {
    #
    # Start udevd first, then hotplug

    logmsg
    logmsg start_udevd
    /etc/init.d/udev start

}

#
################################################################################
#
start_syslogd() {
    logmsg
    logmsg start_syslogd
    if [ ! -z $LOG_SERVER ]; then
        logmsg "Starting syslogd..."
        [ -z $LOG_SERVER_PORT ] && LOG_SERVER_PORT="514"
        syslogd -R ${LOG_SERVER}:${LOG_SERVER_PORT}
        # as long as we are starting syslogd, start klogd as well, in case
        # there is a kernel issue that happens
        klogd
        # set USELOGGER=1 so logmsg knows to do the right thing
        USELOGGER=1
        logmsg "Successfully started syslogd!"
    fi
}

#
################################################################################
#
choose_autoinstall_script() {

    logmsg
    logmsg choose_autoinstall_script

    #
    # Get the base hostname for the last attempt at choosing an autoinstall
    # script.  For example, if the hostname is compute99, then try to get 
    # compute.master. -BEF-
    #
    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    # 
    # If SCRIPTNAME is specified as a kernel append, or via local.cfg, then use that script.
    #
    if [ ! -z $SCRIPTNAME ]; then
        #
        # SCRIPTNAME was specified, but let's be flexible.  Try explicit first, then .master, .sh. -BEF-
        #
        SCRIPTNAMES="${SCRIPTS_DIR}/${SCRIPTNAME} ${SCRIPTS_DIR}/${SCRIPTNAME}.sh ${SCRIPTS_DIR}/${SCRIPTNAME}.master"

    else
        # 
        # If SCRIPTNAME was not specified, choose one, in order of preference.  First hit wins.
        # Order of preference is:
        #   HOSTNAME                (i.e. node001.sh)
        #   GROUPNAMES              (i.e. Login.sh) - see /etc/systemimager/cluster.xml on the image server
        #   BASE_HOSTNAME           (i.e. node.sh)
        #   IMAGENAME               (i.e. ubuntu7_04.sh)
        #
        [ ! -z $HOSTNAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${HOSTNAME}.sh ${SCRIPTS_DIR}/${HOSTNAME}.master"
        for GROUPNAME in $GROUPNAMES; do
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${GROUPNAME}.sh ${SCRIPTS_DIR}/${GROUPNAME}.master"
        done
        unset GROUPNAME
        [ ! -z $BASE_HOSTNAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${BASE_HOSTNAME}.sh ${SCRIPTS_DIR}/${BASE_HOSTNAME}.master"
        [ ! -z $IMAGENAME ] && \
            SCRIPTNAMES="${SCRIPTNAMES} ${SCRIPTS_DIR}/${IMAGENAME}.sh ${SCRIPTS_DIR}/${IMAGENAME}.master"
    fi

    #
    # Choose a winner!
    #
    for SCRIPTNAME in $SCRIPTNAMES
    do
        [ -e $SCRIPTNAME ] && break
    done

    # Did we really find one, or just exit the loop without a 'break'
    if [ ! -e $SCRIPTNAME ]; then
        logmsg "FATAL: couldn't find any of the following autoinstall scripts!"
        logmsg "---"
        logmsg ${SCRIPTNAMES}
        logmsg "---"
	logmsg "Be sure that at least one of the scripts above exists in"
        logmsg "the autoinstall scripts directory on your image server."
        logmsg
        logmsg "See also: si_mkautoinstallscript(8)."
        shellout
    fi
    logmsg "Using autoinstall script: ${SCRIPTNAME}"
}
#
################################################################################
#
run_autoinstall_script() {

    logmsg
    logmsg run_autoinstall_script

    # Run the autoinstall script.
    chmod 755 $SCRIPTNAME || shellout
    logmsg ">>> $SCRIPTNAME"
    $SCRIPTNAME || shellout
}
#
################################################################################
#
# Description: remove duplicated elements from a list, preserving the order.
#
unique() {
    ret=
    for i in $*; do
        flag=0
        for j in $ret; do
            [ "$i" = "$j" ] && flag=1 && break
        done
        [ $flag -eq 0 ] && ret="$ret $i"
    done
    echo $ret
    unset i j flag ret
}
#
################################################################################
#
# Description: reverse a list
#
reverse() {
    ret=
    for i in $*; do
        ret="$i $ret"
    done
    echo $ret
    unset i
}
#
################################################################################
#
run_pre_install_scripts() {

    logmsg
    logmsg run_pre_install_scripts

    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    if [ -e "${SCRIPTS_DIR}/pre-install/" ]; then

        cd ${SCRIPTS_DIR}/pre-install/

        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]all\..*"`"
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${IMAGENAME}\..*"`"
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${BASE_HOSTNAME}\..*"`"
        for GROUPNAME in ${GROUPNAMES}; do
            PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${GROUPNAME}\..*"`"
        done
        unset GROUPNAME
        PRE_INSTALL_SCRIPTS="$PRE_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${HOSTNAME}\..*"`"

        # Now, to get rid of those pesky newlines. -BEF-
        PRE_INSTALL_SCRIPTS=`echo $PRE_INSTALL_SCRIPTS | tr '\n' ' '`
        
        if [ ! -z "`echo ${PRE_INSTALL_SCRIPTS}|sed 's/ //'`" ]; then

            for PRE_INSTALL_SCRIPT in `unique $PRE_INSTALL_SCRIPTS`
            do
                logmsg ">>> $PRE_INSTALL_SCRIPT"
                chmod +x $PRE_INSTALL_SCRIPT || shellout
                ./$PRE_INSTALL_SCRIPT || shellout
            done
        else
            logmsg "No pre-install scripts found."
        fi

        if [ -e "/tmp/pre-install_variables.txt" ]; then
            . /tmp/pre-install_variables.txt
        fi

    fi
}
#
################################################################################
#
run_post_install_scripts() {

    logmsg
    logmsg run_post_install_scripts

    get_base_hostname

    # Get group name (defined in /etc/systemimager/cluster.xml on the image
    # server). -AR-
    get_group_name

    if [ -e "${SCRIPTS_DIR}/post-install/" ]; then

        # make a copy of variables.txt available to post-install scripts -BEF-
        cp -f /tmp/variables.txt ${SCRIPTS_DIR}/post-install/

        cd ${SCRIPTS_DIR}/post-install/

        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]all\..*"`"
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${IMAGENAME}\..*"`"
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${BASE_HOSTNAME}\..*"`"
        for GROUPNAME in ${GROUPNAMES}; do
            POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${GROUPNAME}\..*"`"
        done
        POST_INSTALL_SCRIPTS="$POST_INSTALL_SCRIPTS `ls | grep "^[0-9][0-9]${HOSTNAME}\..*"`"

        # Now, to get rid of those pesky newlines. -BEF-
        POST_INSTALL_SCRIPTS=`echo $POST_INSTALL_SCRIPTS | tr '\n' ' '`
        
        if [ ! -z "`echo ${POST_INSTALL_SCRIPTS}|sed 's/ //'`" ]; then

            mkdir -p /a/tmp/post-install/ || shellout

            rsync -a ${SCRIPTS_DIR}/post-install/ /a/tmp/post-install/ || shellout

            for POST_INSTALL_SCRIPT in `unique $POST_INSTALL_SCRIPTS`
            do
                if [ -e "$POST_INSTALL_SCRIPT" ]; then
                    logmsg ">>> $POST_INSTALL_SCRIPT"
                    chmod +x /a/tmp/post-install/$POST_INSTALL_SCRIPT || shellout
                    chroot /a/ /tmp/post-install/$POST_INSTALL_SCRIPT || shellout
                fi
            done
        else
            logmsg "No post-install scripts found."
        fi

        # Clean up post-install script directory.
        rm -rf /a/tmp/post-install/ || shellout
    fi
}

#
################################################################################
#
#  send_monitor_msg
#
#   Description:
#   Redirect a message to the monitor server.
#
#   Usage: send_monitor_msg "var=$msg"
#

send_monitor_msg() {
    if [ -z $MONITOR_SERVER ]; then
        return
    fi
    if [ -z $MONITOR_PORT ]; then
        MONITOR_PORT=8181
    fi

    # Message to send.
    msg=`echo "$@"`

    # Get the client mac address.
    if [ -z "$mac" ]; then
        mac=`ifconfig $DEVICE 2>/dev/null | sed -ne "s/.*HWaddr //p" | sed "s/ //g" | sed s/:/./g`
    fi

    # Collect some special info only after proc file system is mounted.
    if [ `mount 2>/dev/null | grep proc > /dev/null; echo $?` -eq 0 ]; then
        # Collect the CPU info.
        if [ -z "$cpu" ]; then
            cpu=$(echo `cat /proc/cpuinfo | grep "cpu\|clock\|model name\|cpu MHz" | grep -v "cpu family" | sed -ne '1,2p' | sed "s/.*: //" | sed "s/^\([0-9\.]*\)MHz$/(\1 MHz)/" | sed "s/^\([0-9\.]*\)$/(\1 MHz)/"` | sed "s/\(MHz)\)/\1 |/g" | sed "s/ |$//")
        fi

        # Collect the number of CPUs.     
        if [ -z "$ncpus" ]; then
            ncpus=$((`cat /proc/cpuinfo | grep "^processor" | sed -n '$p' | sed "s/.*: \([0-9]\)*$/\1/"` + 1))
        fi

        # Collect the kernel information.
        if [ -z "$kernel_name" ]; then
            kernel_name=`uname -r`
        fi

        # Collect the amount of phyisical memory.
        if [ -z "$mem" ]; then
            mem=`cat /proc/meminfo | sed -ne "s/MemTotal: *//p" | sed "s/ kB//"`
        fi

        # Evaluate the amount of available RAM.
        tmpfs=`df | grep tmpfs | grep "/$" | sed "s/.* \([0-9]*%\) .*/\1/"`

        # Evaluate the uptime of the client.
        time=`cat /proc/uptime | sed "s/\..*//"`
    fi

    # Report the message to the monitor server.
    send_msg=`echo "mac=$mac:ip=$IPADDR:host=$HOSTNAME:cpu=$cpu:ncpus=$ncpus:kernel=$kernel_name:mem=$mem:os=$IMAGENAME:tmpfs=$tmpfs:time=$time:$msg"`

    # Send data to monitor server.
    echo "$send_msg" | nc $MONITOR_SERVER $MONITOR_PORT
}
#
################################################################################
#
#  send_monitor_stdout
#
#   Description:
#   Redirect a stdout of a command to the monitor console.
#
#   Usage: <cmd> | send_monitor_stdout
#

send_monitor_stdout() {
    while read l; do
        # echo to the console -AR-
        echo "$l"
        # Send the message to the monitor daemon.
        if [ "x$MONITOR_CONSOLE" = "xy" ]; then
            MONITOR_CONSOLE=yes
        fi
        if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
            # Log message into the global monitor log.
            if fs_on_tmpfs / ; then
                echo "$l" >> /tmp/si_monitor.log
            fi
        fi
    done
}
#
################################################################################
#
#   Initialize the monitor server
#

init_monitor_server() {
    # Send initialization status.
    send_monitor_msg "status=0:first_timestamp=on:speed=0"
    logmsg "Monitoring initialized."
    # Start client log gathering server: for each connection
    # to the local client on port 8181 the full log is sent
    # to the requestor. -AR-
    if [ "x$MONITOR_CONSOLE" = "xy" ]; then
        MONITOR_CONSOLE=yes
    fi
    if [ "x$MONITOR_CONSOLE" = "xyes" ]; then
        while :; do nc -p 8181 -l < /tmp/si_monitor.log; done &
    fi
}
#
################################################################################
#
#   Report installation status to the monitor server
#

start_report_task() {
    # Reporting interval (in sec).
    REPORT_INTERVAL=10

    # Evaluate image size.
    logmsg "Evaluating image size..."
    if [ ! "x$BITTORRENT" = "xy" ]; then
        IMAGESIZE=`rsync -av --numeric-ids $IMAGESERVER::$IMAGENAME | grep "total size" | sed -e "s/total size is \([0-9]*\).*/\1/"`
    else
        if [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent" ]; then
            torrent_file="${TORRENTS_DIR}/image-${IMAGENAME}.tar.torrent"
        elif [ -f "${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent" ]; then
            torrent_file="${TORRENTS_DIR}/image-${IMAGENAME}.tar.gz.torrent"
        else
            logmsg "error: cannot find a valid torrent file for image ${IMAGENAME}"
            shellout
        fi
        IMAGESIZE=`aria2c -S $torrent_file | awk '/Total Length:/ { print $4}' | sed 's/[(),]*//g'`
    fi
    IMAGESIZE=`expr $IMAGESIZE / 1024`
    logmsg "  --> Image size = `expr $IMAGESIZE / 1024`MiB"

    # Evaluate disks size.
    LIST=`df 2>/dev/null | grep "/" | sed "s/  */ /g" | cut -d' ' -f3 | sed -ne 's/^\([0-9]*\)$/\1+/p'`0
    DISKSIZE=`echo $LIST | bc`

    # Spawn the report task -AR-
    {
    TOT=0; CURR_SIZE=0
    while :; do
        LIST=`df 2>/dev/null | grep "/" | sed "s/  */ /g" | cut -d' ' -f3 | sed -ne 's/^\([0-9]*\)$/\1+/p'`0
        TOT=`echo $LIST | bc`

        # Evaluate bandwidth.
        speed=`echo "scale=2; (($TOT - $DISKSIZE) - $CURR_SIZE) / $REPORT_INTERVAL" | bc`
        speed=`echo "scale=2; if ($speed >= 0) { print $speed; } else { print 0; }" | bc`

        # Evaluate status.
        CURR_SIZE=$(($TOT - $DISKSIZE))
        status=`echo "scale=2; $CURR_SIZE * 100 / $IMAGESIZE" | bc`
        if [ `echo "scale=2; $status <= 0" | bc` -eq 1 ]; then 
            status=1
        elif [ `echo "scale=2; $status >= 100" | bc` -eq 1 ]; then
            status=99
        fi

        # Send status and bandwidth to the monitor server.
        send_monitor_msg "status=$status:speed=$speed"
        
        # Wait $REPORT_INTERVAL sec between each report -AR-
        sleep $REPORT_INTERVAL
    done
    }&

    logmsg "Report task started."
    REPORT_PID=$!
}
#
################################################################################
#
#   Stop to report installation status to the monitor server
#

stop_report_task() {
    if [ ! -z $REPORT_PID ]; then
        kill -9 $REPORT_PID
        logmsg "Report task stopped."
    fi

    # Try to report the error to the monitor server.
    send_monitor_msg "status=$1:speed=0"
}
#
################################################################################
#
#   Beep incessantly
#
beep_incessantly() {
    local SECONDS=1
    local MINUTES
    local MINUTES_X_SIXTY
    { while :;
        do
            echo -n -e "\\a"
            if [ $SECONDS -lt 60 ]; then 
                logmsg "I have been done for $SECONDS seconds.  Reboot me already!"
            else
                MINUTES=`echo "$SECONDS / 60"|bc`
                MINUTES_X_SIXTY=`echo "$MINUTES * 60"|bc`
                if [ "$MINUTES_X_SIXTY" = "$SECONDS" ]; then 
                    logmsg "I have been done for $MINUTES minutes now.  Reboot me already!"
                fi  
            fi
            sleep 1
            SECONDS=`echo "$SECONDS + 1"|bc`
        done
    }
}
#
################################################################################
#
#   Beep incessantly
#
# Usage: beep [$COUNT [$INTERVAL]]
# Usage: beep
beep() {
    local COUNT=$1
    local INTERVAL=$2

    [ -z $COUNT ] && COUNT=1
    [ -z $INTERVAL ] && INTERVAL=1

    local COUNTED=0
    until [ "$COUNTED" = "$COUNT" ]
    do
        echo -n -e "\\a"
        sleep $INTERVAL
        COUNTED=$(( $COUNTED + 1 ))
    done
}
#
################################################################################
#
#   Print out dots while sleeping
#
# Usage: sleep_loop [[$COUNT [$INTERVAL]] $CHARACTER]
# Usage: sleep_loop
sleep_loop() {
    local COUNT=$1
    local INTERVAL=$2
    local CHARACTER=$3
    local COUNTED

    [ -z $COUNT ] && COUNT=1
    [ -z $INTERVAL ] && INTERVAL=1
    [ -z $CHARACTER ] && CHARACTER=.

    COUNTED=0
    until [ "$COUNTED" = "$COUNT" ]
    do
        echo -n "$CHARACTER"
        sleep $INTERVAL
        COUNTED=$(( $COUNTED + 1 ))
    done
}
#
################################################################################
