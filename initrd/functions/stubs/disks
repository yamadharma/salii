
blockdev(){
	logmsg "blockdev is depricated"
}

find_all_disks(){
	## 
	# First find all disks, we are only interested the whole disk, eg: /dev/sda
	# line to parse:
	#  lrwxrwxrwx 1 root root  9 2010-04-05 12:40 pci-0000:02:0e.0-scsi-0:2:0:0 -> ../../sda
	#  lrwxrwxrwx 1 root root 10 2010-04-05 12:40 pci-0000:02:0e.0-scsi-0:2:0:0-part1 -> ../../sda1
	#

	if [ -e /dev/disk/by-id ]
	then
		disks=$(ls -l /dev/disk/by-id | grep -v part | awk '{ print $NF }' | sort -u)
	elif [ -e /dev/disk/by-path ]
	then
		disks=$(ls -l /dev/disk/by-path | grep -v part | awk '{ print $NF }' | sort -u)
	elif [ -e /dev/disk/by-label ]
	then
		disks=$(ls -l /dev/disk/by-label | grep -v part | awk '{ print $NF }' | sort -u)
	else
		logmsg
		logmsg "Can't find any disk by either path, id or label in /dev/disk"
		logmsg
		shellout
	fi

	for d in $disks
	do
		case $(dirname $d) in
			../../*)
				controller="$(basename $(dirname $d))/"
			;;
			*)
				controller=""
			;;
		esac

		case $d in
			../*)
				if [ "$(cat /proc/partitions | grep $(basename $d))" ]
				then
					echo "$controller$(basename $d)"
				fi
			;; 
		esac
	done

}

disk_enumerate(){
	##  To support the following syntax's
	#    - A=",a,b,,c" --> A="a b c"
	#
	ORDER=$( echo $1 | sed 's/,/ /g' | sed 's/,,*/ /g' | sed 's/^,/ /' )

	ALLDISKS=$(find_all_disks)
	NUMDISKS=-1

	for order in $ORDER
	do
		for disk in $ALLDISKS
		do
			found=$(echo $disk | grep $order)
			if [ $found ]
			then
				echo "A disk found: $disk"
				NUMDISKS=$(( $NUMDISKS + 1 ))
				eval "DISK$NUMDISKS=/dev/$disk"
			fi
		done
	done
}

## Sets the disklabel for a specified disk
# Usage: set_disklabel disk label
#   labels: bsd|dvh|gpt|loop|mac|msdos|pc98|sun

set_disklabel(){

	DISK=$1
	LABEL=$2

	if [ -e $DISK ]
	then
		case $LABEL in
			bsd|dvh|gpt|loop|mac|msdos|pc98|sun)
         	              	parted -s -- $DISK mklabel $LABEL
                        ;;

			*)
				logmsg
				logmsg "Label not supported: $LABEL"
				shellout
			;;
                esac
	else
		logmsg
		logmsg "Disk not found: $DISK"
		shellout
	fi
}

## Shows the disksize
# Usage: get_disksize disk
get_disksize(){

	DISK=$1 
	
	if [ -e $DISK ]
	then
		echo $(parted -s $DISK unit MB print|awk '/^Disk/ {print $3}'|sed 's/[Mm][Bb]//')
	else
		logmsg
		logmsg "Disk not found!"
		shellout
        fi
}

## Create Filesystem
#
# This function will format the TARGET and put a LABEL on it 
# if specified. The TARGET can be a partition or volume
#
# Usage create_filesystem <target> <fs_type> [LABEL]
#   
create_filesystem(){

	TARGET=$1
	FS_TYPE=$2
	DISK_LABEL=$3

	logmsg
	logmsg "create_filesystem: $TARGET $FS_TYPE $DISK_LABEL"

	case "$FS_TYPE" in
		ext2|ext3|ext4)
			logmsg "   mkfs.$FS_TYPE -q $TARGET"
			mkfs.$FS_TYPE -q $TARGET || shellout
			if [ "$DISK_LABEL" ]; then
				logmsg "   tune2fs -L $DISK_LABEL $TARGET"
				tune2fs -L $DISK_LABEL $TARGET || shellout
			fi
		;;
		xfs)
			logmsg "   mkfs.xfs -f -q $TARGET"
			mkfs.xfs -f -q $TARGET || shellout
			if [ "$LABEL" ]; then
				logmsg "   xfs_db -x -c 'label $DISK_LABEL' $TARGET"
				xfs_db -x -c "label $DISK_LABEL" $TARGET || shellout
			fi
		;;
		swap)
			if [ "$DISK_LABEL" ]; then
				DISK_LABEL="-L $DISK_LABEL "
			else
				DISK_LABEL=""
			fi
			logmsg "   mkswap $SWAPLABEL$PARTITION"
			mkswap $DISK_LABEL $TARGET || shellout
		;;
		ext2.128)
			logmsg "   mkfs.ext2 -I 128 -q $TARGET"
			mkfs.ext2 -I 128 -q $TARGET || shellout
			if [ "$DISK_LABEL" ]; then
				logmsg "   tune2fs -L $DISK_LABEL $TARGET"
				tune2fs -L $DISK_LABEL $TARGET || shellout
			fi
			;;
	esac
}
	

##
# Creates partitions
#
# Usage: partition disk partitionstring
#   partition /dev/sda 1024:ext2:/boot:boot 1:grub2 4096:swap::swap 0:xfs:/:root
#    This will create four partitions
#
# partitionstring == size:type:mount:label
#  size* | specify the size of the disk in MB, 0 means use rest/all of the disk
#  type* | this value is required, when the disk should not be formatted specify none
#  mount | none or nothing can specified when the disk has no mount path, ie. swap
#  label | can be empty
#   * == required
#
# Swap example no label: 4096:swap
# Swap example label: 4096:swap::swap or 4096:swap:none:swap
# Disk xfs no label: 4096:xfs:/var
# Disk xfs label: 4096:xfs:/var:var

partition(){
	DISK=$1
	DISKNAME=$(basename $1)
	
	if [ ! -e $DISK ]; then
		logmsg
		logmsg "Disk not found, stopping"
		shellout
	fi
	
	DISKSIZE=$(get_disksize $DISK)
	END_OF_LAST=1
	NUMPARTITIONS=0
	

	logmsg
	logmsg "Partition disk: $DISK $DISKSIZE"

	while [ $# -gt 0 ]; do

		SIZE=$( echo $1 | awk -F ":" '{ print $1 }' )
		TYPE=$( echo $1 | awk -F ":" '{ print $2 }' )
		MOUNTPATH=$( echo $1 | awk -F ":" '{ print $3 }' ) 
		LABEL=$( echo $1 | awk -F ":" '{ print $4 }' )

		if [ ! "$SIZE" ] && [ ! "$TYPE" ]; then
			logmsg
			logmsg "Size and input are required, size:type"
			logmsg
			break
		fi

		NUMPARTITIONS=$(( $NUMPARTITIONS + 1 ))
		
		logmsg
		logmsg "Create partition $NUMPARTITIONS on disk $DISK"

		case "$SIZE" in
			0)
				START_MB=$END_OF_LAST
				END_MB=$(( DISKSIZE - 0 ))
				logmsg "   parted -s -- $DISK mkpart primary $START_MB $END_MB"
				parted -s -- $DISK mkpart primary $START_MB $END_MB 
				END_OF_LAST=$END_MB
				sleep 1
			;;
			*)
				START_MB=$END_OF_LAST
				END_MB=$(($START_MB + $SIZE))
				logmsg "   parted -s -- $DISK mkpart primary $START_MB $END_MB"
				parted -s -- $DISK mkpart primary $START_MB $END_MB
				END_OF_LAST=$END_MB
				sleep 1
			;;
		esac

		PARTITION=""
		if [ ! -e $DISK$NUMPARTITIONS ]
		then
			if [ -e ${DISK}p$NUMPARTITIONS ]
			then
				PARTITION="${DISK}p$NUMPARTITIONS"
			fi
		else
			PARTITION="$DISK$NUMPARTITIONS"
		fi

		##
		# If the value of the $LABEL is none, clear it.
		if [ "$LABEL" == "none" ]; then
			LABEL=""
		fi

		## There is an exception for grub2
		#
		case "$TYPE" in

			grub2|grub_bios)
				logmsg "   parted -s -- $DISK set $NUMPARTITIONS bios_grub on"
				parted -s -- $DISK set $NUMPARTITIONS bios_grub on || shellout
			;;

			*) 
				create_filesystem $PARTITION $TYPE $LABEL
			;;
		esac

		if [ ! "$MOUNTPATH" ]
		then
			logmsg
			logmsg "$PARTITION does not need a mount"
			logmsg
		else
			create_	
		fi

		##
		# When a mountpath is specified, write the path, disk and type to a file
		# this file shall be used during mounting and umounting the disks
		case "$MOUNTPATH" in
			none)
				logmsg
				logmsg "$PARTITION does not need a mount"
				logmsg
			;;
			
			*)
				create_disk_mount_file $DISKNAME $MOUNTPATH $TYPE $PARTITION 
			;;
		
		esac
		shift

	done  # end while

	logmsg
}

##
# Create a mount file for diskname in /tmp/mounts.<diskname>. The format is:
#  <mount path> <FS_TYPE> <TARGET>
#
# create_disk_mount_file DISK MOUNTPATH FS_TYPE TARGET
#
create_disk_mount_file(){

	if [ $# -lt 4 ]
	then
		echo "Usage: create_disk_mount_file DISK MOUNTPATH FS_TYPE TARGET"
		shellout
	fi

	FILE=/tmp/mounts.$1
	touch $FILE

	## 
	# The root filesystem must be mounted first and then the rest
	#
	case $2 in
		/)
			echo "0 /a$2 $3 $4" >> $FILE
		;;

		*)
			echo "1 /a$2 $3 $4" >> $FILE
		;;
	esac
}



chroot_mount_system_fs(){

	logmsg "Mounting /proc /sys and /dev to /a"

	logmsg "mkdir -p /a/proc"
	mkdir -p /a/proc
	logmsg "mount proc /a/proc -t proc -o defaults"
	mount proc /a/proc -t proc -o defaults

	logmsg "mkdir -p /a/sys"
	mkdir -p /a/sys
	logmsg "mount sysfs /a/sys -t sysfs -o defaults"
	mount sysfs /a/sys -t sysfs -o defaults

	logmsg "mkdir -p /a/dev"
	mkdir -p /a/dev
	logmsg "mount /dev /a/dev -o bind"
	mount /dev /a/dev -o bind

	logmsg
}

chroot_umount_system_fs(){

	logmsg "Umounting /proc /sys and /dev to /a"

	logmsg "umount /a/proc"
	umount /a/proc

	logmsg "umount /a/sys"
	umount /a/sys

	logmsg "umount /a/dev"
	umount /a/dev

	logmsg
}

## Allows you to mount disks according the information stored in /tmp/mounts.*
#   - mount_disks --> mount all possible partitions
#   - mount_disks /dev/sdb --> only mount partitions of disk sdb
mount_disks(){

	if [ $1 ]
	then
		DISK=$( basename $1)
	else
		DISK=*
	fi

	cat /tmp/mounts.$DISK | sort -u | while read priority path type device
	do
		if [ ! -e $path ]; then
			logmsg "mkdir -p $path"
			mkdir -p $path
		else
			logmsg "Directory exists!, $path"
		fi

		if [ ! "$(df | grep $device)" ]
		then
			sleep 2
		        logmsg "mount -t $type $device $path"
			mount -t $type $device $path
			sleep 2
		else
			logmsg "device already mounted: $path -> $device"
		fi

	done

	logmsg
}

## Allows you to umount disks according the information stored in /tmp/mounts.*
#   - umount_disks --> umount all possible devices
#   - umount_disks /dev/sdb --> only umount devices for disk sdb
umount_disks(){

	if [ $1 ]
	then
		DISK=$( basename $1)
	else
		DISK=*
	fi

	cat /tmp/mounts.$DISK | sort -ru | while read priority path type device
	do
		if [ "$(df | grep $device)" ]
		then
		        logmsg "umount $path"
			umount $path
			sleep 2
		else
			logmsg "device already umounted: $path -> $device"
		fi

	done

	logmsg
}
