
blockdev(){
	logmsg "blockdev is depricated"
}

find_all_disks(){
	## 
	# First find all disks, we are only interested the whole disk, eg: /dev/sda
	# line to parse:
	#  lrwxrwxrwx 1 root root  9 2010-04-05 12:40 pci-0000:02:0e.0-scsi-0:2:0:0 -> ../../sda
	#  lrwxrwxrwx 1 root root 10 2010-04-05 12:40 pci-0000:02:0e.0-scsi-0:2:0:0-part1 -> ../../sda1
	#
	disks=$(ls -l /dev/disk/by-id | grep -v part | awk '{ print $NF }' | sort -u)

	for d in $disks
	do
		case $d in
			../*) 
				echo $(basename $d)
			;; 
		esac
	done
}

disk_enumerate(){
	##  To support the following syntax's
	#    - A=",a,b,,c" --> A="a b c"
	#
	ORDER=$( echo $1 | sed 's/,/ /g' | sed 's/,,*/ /g' | sed 's/^,/ /' )

	ALLDISKS=$(find_all_disks)
	NUMDISKS=-1

	for order in $ORDER
	do
		for disk in $ALLDISKS
		do
			found=$(echo $disk | grep $order)
			if [ $found ]
			then
				echo "A disk found: $disk"
				NUMDISKS=$(( $NUMDISKS + 1 ))
				eval "DISK$NUMDISKS=/dev/$disk"
			fi
		done
	done
}

## Sets the disklabel for a specified disk
# Usage: set_disklabel label disk
#   labels: bsd|dvh|gpt|loop|mac|msdos|pc98|sun

set_disklabel(){

	DISK=$1
	LABEL=$2

	if [ -e $DISK ]
	then
		case $LABEL in
			bsd|dvh|gpt|loop|mac|msdos|pc98|sun)
         	              	parted -s -- $DISK mklabel $LABEL
                        ;;

			*)
				logmsg
				logmsg "Label not supported: $LABEL"
				shellout
			;;
                esac
	else
		logmsg
		logmsg "Disk not found: $DISK"
		shellout
	fi
}

## Shows the disksize
# Usage: get_disksize disk
get_disksize(){

	DISK=$1 
	
	if [ -e $DISK ]
	then
		echo $(parted -s $DISK unit MB print|awk '/^Disk/ {print $3}'|sed 's/[Mm][Bb]//')
	else
		logmsg
		logmsg "Disk not found!"
		shellout
        fi
}

##
# Creates partitions
#
# Usage: partition disk partitionstring
#   partition /dev/sda 1024:ext2:/boot:boot 1:grub2 4096:swap::swap 0:xfs:/:root
#    This will create four partitions
#
# partitionstring == size:type:mount:label
#  size* | specify the size of the disk in MB, 0 means use rest/all of the disk
#  type* | this value is required, when the disk should not be formatted specify none
#  mount | none or nothing can specified when the disk has no mount path, ie. swap
#  label | can be empty
#   * == required
#
# Swap example no label: 4096:swap
# Swap example label: 4096:swap::swap or 4096:swap:none:swap
# Disk xfs no label: 4096:xfs:/var
# Disk xfs label: 4096:xfs:/var:var

partition(){
	DISK=$1
	DISKBASE=$(basename $1)
	
	if [ ! -e $DISK ]; then
		logmsg
		logmsg "Disk not found, stopping"
		shellout
	fi
	
	DISKSIZE=$(get_disksize $DISK)
	END_OF_LAST=1
	NUMPARTITIONS=0
	
	if [ ! -e /tmp/mounts ]; then
		touch /tmp/mounts.$DISKBASE
	fi
	
	shift

	logmsg
	logmsg "Partition disk: $DISK $DISKSIZE"

	while [ $# -gt 0 ]; do

		SIZE=$( echo $1 | awk -F ":" '{ print $1 }' )
		TYPE=$( echo $1 | awk -F ":" '{ print $2 }' )
		MOUNTPATH=$( echo $1 | awk -F ":" '{ print $3 }' ) ## If swap is used, this is the label
		LABEL=$( echo $1 | awk -F ":" '{ print $4 }' )

		if [ ! "$SIZE" ] && [ ! "$TYPE" ]; then
			logmsg
			logmsg "Size and input are required, size:type"
			logmsg
			break
		fi

		NUMPARTITIONS=$(( $NUMPARTITIONS + 1 ))
		logmsg
		logmsg "Partition $DISK$NUMPARTITIONS"

		case "$SIZE" in
			0)
				START_MB=$END_OF_LAST
				END_MB=$(( DISKSIZE - 0 ))
				logmsg "   parted -s -- $DISK mkpart primary $START_MB $END_MB"
				parted -s -- $DISK mkpart primary $START_MB $END_MB 
				END_OF_LAST=$END_MB
				sleep 1
			;;
			*)
				START_MB=$END_OF_LAST
				END_MB=$(($START_MB + $SIZE))
				logmsg "   parted -s -- $DISK mkpart primary $START_MB $END_MB"
				parted -s -- $DISK mkpart primary $START_MB $END_MB
				END_OF_LAST=$END_MB
				sleep 1
			;;
		esac

		##
		# If the value of the $LABEL is none, clear it.
		if [ "$LABEL" == "none" ]; then
			LABEL=""
		fi

		case "$TYPE" in
			ext2|ext3|ext4)
				logmsg "   mkfs.$TYPE -q $DISK$NUMPARTITIONS"
				mkfs.$TYPE -q $DISK$NUMPARTITIONS || shellout
				if [ "$LABEL" ]; then
					logmsg "   tune2fs -L $LABEL $DISK$NUMPARTITIONS"
					tune2fs -L $LABEL $DISK$NUMPARTITIONS || shellout
				fi
			;;
			xfs)
				logmsg "   mkfs.xfs -f -q $DISK$NUMPARTITIONS"
				mkfs.xfs -f -q $DISK$NUMPARTITIONS || shellout
				if [ "$LABEL" ]; then
					logmsg "   xfs_db -x -c 'label $LABEL' $DISK$NUMPARTITIONS"
					xfs_db -x -c "label $LABEL" $DISK$NUMPARTITIONS || shellout
				fi
			;;
			swap)
				if [ "$LABEL" ]; then
					SWAPLABEL="-L $LABEL "
				else
					SWAPLABEL=""
				fi
				logmsg "   mkswap $SWAPLABEL$DISK$NUMPARTITIONS"
				mkswap $SWAPLABEL$DISK$NUMPARTITIONS || shellout
			;;
			grub2|grub_bios)
				logmsg "   parted -s -- $DISK set $NUMPARTITIONS bios_grub on"
				parted -s -- $DISK set $NUMPARTITIONS bios_grub on || shellout
			;;
			ext2.128)
				TYPE=$( echo $TYPE | awk -F "." '{print $1}')
				logmsg "   mkfs.ext2 -I 128 -q $DISK$NUMPARTITIONS"
				mkfs.ext2 -I 128 -q $DISK$NUMPARTITIONS || shellout
				if [ "$LABEL" ]; then
					logmsg "   tune2fs -L $LABEL $DISK$NUMPARTITIONS"
					tune2fs -L $LABEL $DISK$NUMPARTITIONS || shellout
				fi
			;;
		esac

		if [ ! "$MOUNTPATH" ]
		then
			MOUNTPATH="none"
		fi

		##
		# When a mountpath is specified, write the path, disk and type to a file
		# this file shall be used during mounting and umounting the disks
		case "$MOUNTPATH" in
			none)
				logmsg
				logmsg "$DISK$NUMPARTITION does not need a mount"
				logmsg
			;;
			/)
				echo "0 /a$MOUNTPATH $TYPE $DISK$NUMPARTITIONS" >> /tmp/mounts.$DISKBASE
			;;
			*)
				echo "1 /a$MOUNTPATH $TYPE $DISK$NUMPARTITIONS" >> /tmp/mounts.$DISKBASE
			;;
		esac

		shift
	done

	logmsg
}

chroot_mount_system_fs(){

	logmsg "Mounting /proc /sys and /dev to /a"

	logmsg "mkdir -p /a/proc"
	mkdir -p /a/proc
	logmsg "mount proc /a/proc -t proc -o defaults"
	mount proc /a/proc -t proc -o defaults

	logmsg "mkdir -p /a/sys"
	mkdir -p /a/sys
	logmsg "mount sysfs /a/sys -t sysfs -o defaults"
	mount sysfs /a/sys -t sysfs -o defaults

	logmsg "mkdir -p /a/dev"
	mkdir -p /a/dev
	logmsg "mount /dev /a/dev -o bind"
	mount /dev /a/dev -o bind

	logmsg
}

chroot_umount_system_fs(){

	logmsg "Umounting /proc /sys and /dev to /a"

	logmsg "umount /a/proc"
	umount /a/proc

	logmsg "umount /a/sys"
	umount /a/sys

	logmsg "umount /a/dev"
	umount /a/dev

	logmsg
}

## Allows you to mount disks according the information stored in /tmp/mounts.*
#   - mount_disks --> mount all possible partitions
#   - mount_disks /dev/sdb --> only mount partitions of disk sdb
mount_disks(){

	if [ $1 ]
	then
		DISK=$( basename $1)
	else
		DISK=*
	fi

	cat /tmp/mounts.$DISK | sort -u | while read priotity path type disk
	do
		if [ ! -e $path ]; then
			logmsg "mkdir -p $path"
			mkdir -p $path
		else
			logmsg "Directory exists!, $path"
		fi

		if [ ! "$(df | grep $disk)" ]
		then
			sleep 2
		        logmsg "mount -t $type $disk $path"
			mount -t $type $disk $path
			sleep 2
		else
			logmsg "disk already mounted: $path -> $disk"
		fi

	done

	logmsg
}

## Allows you to umount disks according the information stored in /tmp/mounts.*
#   - umount_disks --> umount all possible partitions
#   - umount_disks /dev/sdb --> only umount partitions of disk sdb
umount_disks(){

	if [ $1 ]
	then
		DISK=$( basename $1)
	else
		DISK=*
	fi

	cat /tmp/mounts.$DISK | sort -ru | while read priotity path type disk
	do
		if [ "$(df | grep $disk)" ]
		then
		        logmsg "umount $path"
			umount $path
			sleep 2
		else
			logmsg "disk already umounted: $path -> $disk"
		fi

	done

	logmsg
}
