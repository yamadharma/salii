
#
################################################################################
#
#  send_monitor_msg
#
#   Description:
#   Redirect a message to the monitor server.
#
#   Usage: send_monitor_msg "var=$msg"
#

send_monitor_msg() {
    if [ -z $MONITOR_SERVER ]; then
        return
    fi
    if [ -z $MONITOR_PORT ]; then
        MONITOR_PORT=8181
    fi

    # Message to send.
    msg=`echo "$@"`

    # Get the client mac address.
    if [ -z "$mac" ]; then
        mac=`ifconfig $DEVICE 2>/dev/null | sed -ne "s/.*HWaddr //p" | sed "s/ //g" | sed s/:/./g`
    fi

    # Collect some special info only after proc file system is mounted.
    if [ `mount 2>/dev/null | grep proc > /dev/null; echo $?` -eq 0 ]; then
        # Collect the CPU info.
        if [ -z "$cpu" ]; then
            cpu=$(echo `cat /proc/cpuinfo | grep "cpu\|clock\|model name\|cpu MHz" | grep -v "cpu family" | sed -ne '1,2p' | sed "s/.*: //" | sed "s/^\([0-9\.]*\)MHz$/(\1 MHz)/" | sed "s/^\([0-9\.]*\)$/(\1 MHz)/"` | sed "s/\(MHz)\)/\1 |/g" | sed "s/ |$//")
        fi

        # Collect the number of CPUs.
        if [ -z "$ncpus" ]; then
            ncpus=$((`cat /proc/cpuinfo | grep "^processor" | sed -n '$p' | sed "s/.*: \([0-9]\)*$/\1/"` + 1))
        fi

        # Collect the kernel information.
        if [ -z "$kernel_name" ]; then
            kernel_name=`uname -r`
        fi

        # Collect the amount of phyisical memory.
        if [ -z "$mem" ]; then
            mem=`cat /proc/meminfo | sed -ne "s/MemTotal: *//p" | sed "s/ kB//"`
        fi

        # Evaluate the amount of available RAM.
        tmpfs=`df | grep tmpfs | grep "/$" | sed "s/.* \([0-9]*%\) .*/\1/"`

        # Evaluate the uptime of the client.
        time=`cat /proc/uptime | sed "s/\..*//"`
    fi

    # Report the message to the monitor server.
    send_msg=`echo "mac=$mac:ip=$IPADDR:host=$HOSTNAME:cpu=$cpu:ncpus=$ncpus:kernel=$kernel_name:mem=$mem:os=$IMAGENAME:tmpfs=$tmpfs:time=$time:$msg"`

    ## So we can support monitoring via web server
    #
    printf "$send_msg\n" >> ${MONITOR_LOG_FILE}

    # Send data to monitor server.
    echo "$send_msg" | nc $MONITOR_SERVER $MONITOR_PORT
}

#
################################################################################
#
#   Report installation status to the monitor server
#

start_report_task() {

    p_stage "Starting reporting"

    . /tmp/variables.txt

    case "${PROTOCOL}" in
        bittorrent|metafile)
            p_service "Enabling reporting for bittorrent/metafile"
            p_comment 0 " note: when progress is 90%% and speed 0 or -, image is unpacking!"
        ;;
        rsync)
            p_service "Enabling reporting for rsync"
            p_comment 0 "  note: it will take a couple of minutes before the reporting starts!"
        ;;
        *)
            p_comment 0 "Given protocol is not supported"
            return
        ;;
    esac

    /bin/sh /bin/report_task &

    REPORT_PID=$!
    export REPORT_PID
    save_param REPORT_PID $REPORT_PID
    p_comment 0 "Report process started, with pid ${REPORT_PID}"
}

#
################################################################################
#
#   Stop to report installation status to the monitor server
#

stop_report_task() {

    if [ ! -z $REPORT_PID ]; then
        killall -9 report_task
        logmsg "Report task stopped."
    fi

    # Try to report the error to the monitor server.
    send_monitor_msg "status=$1:speed=0"
}
